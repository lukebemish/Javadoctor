plugins {
    id 'java'
}
evaluationDependsOn(':injector')
rootProject.subprojects.each {
    if (it.name.startsWith('injector-')) {
        evaluationDependsOn(":${it.name}")
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

repositories {
    maven {
        url 'https://repo.spongepowered.org/repository/maven-public/'
        content {
            includeGroup('org.spongepowered')
        }
    }
    maven {
        url 'https://maven.neoforged.net'
        content {
            includeGroup('net.neoforged')
        }
    }

    maven {
        url 'https://www.jetbrains.com/intellij-repository/releases/'
    }
    maven {
        url 'https://cache-redirector.jetbrains.com/intellij-dependencies/'
    }
}

configurations {
    decompiler
    fart {
        transitive = false
    }
}

dependencies {
    compileOnly 'org.spongepowered:mixin:0.8.5'
    annotationProcessor project(':collector')

    decompiler 'org.vineflower:vineflower:1.9.1'
    fart 'net.neoforged:AutoRenamingTool:1.0.5:all'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testImplementation 'fr.inria.gforge.spoon:spoon-core:10.4.0'
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.0'
}

tasks.named('compileJava', JavaCompile).configure {
    options.compilerArgs.add('-AcollectionPackages=hello,stab')
}

tasks.register('obfJar', ObfuscateTask) {
    group = 'build'
    input.set(tasks.jar.archiveFile)
    mappingsIn.from(file('src/main/resources/mappings.tsrg'))
    doFirst {
        file('src/main/resources/mappings.tsrg').text = file('src/main/resources/mappings.tsrg').text.replace('    ', '\t')
    }
}

tasks.register('decompile', DecompileTask) {
    group = 'build'
    input.set(tasks.obfJar.output)
}

rootProject.subprojects.each { proj ->
    if (proj.name.startsWith('injector-')) {
        final injectorName = proj.name.substring('injector-'.length())
        final confProvider = configurations.register("injector${injectorName.capitalize()}") {
            it.dependencies.add(project.dependencies.create(proj))
        }
        tasks.register("applyDocs${injectorName.capitalize()}", InjectDocsTask) {
            group = 'test'
            input.set(tasks.named('decompile', DecompileTask).flatMap { it.output })
            classpath.from(confProvider)
            javaVersion.set(17)
        }
    }
}

test {
    outputs.upToDateWhen { false }
    useJUnitPlatform()
    dependsOn('applyDocsSpoon')
    dependsOn('applyDocsJavaparser')
    dependsOn('applyDocsJetbrains-psi')

    jvmArgs('-DspoonJar=' + project.file("${project.buildDir}/applyDocsSpoon/output.jar"))
    jvmArgs('-DjavaparserJar=' + project.file("${project.buildDir}/applyDocsJavaparser/output.jar"))
    jvmArgs('-DjbPsiJar=' + project.file("${project.buildDir}/applyDocsJetbrains-psi/output.jar"))
}

abstract class DecompileTask extends DefaultTask {
    @InputFile
    abstract RegularFileProperty getInput()

    @OutputFile
    abstract RegularFileProperty getOutput()

    DecompileTask() {
        output.convention(project.layout.file(project.provider { project.file("${project.buildDir}/${name}/output.jar") }))
    }

    @TaskAction
    void run() {
        output.get().asFile.delete()
        project.javaexec { JavaExecSpec spec ->
            spec.args(input.get().asFile, output.get().asFile)
            spec.jvmArgs('-Xmx256M')
            spec.classpath(project.configurations.decompiler)
            spec.mainClass.set('org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler')
        }
    }
}

abstract class ObfuscateTask extends DefaultTask {
    @InputFile
    abstract RegularFileProperty getInput()

    @OutputFile
    abstract RegularFileProperty getOutput()

    @InputFiles
    abstract ConfigurableFileCollection getMappingsIn()

    ObfuscateTask() {
        output.convention(project.layout.file(project.provider { project.file("${project.buildDir}/${name}/output.jar") }))
    }

    @TaskAction
    void run() {
        output.get().asFile.delete()
        project.javaexec { JavaExecSpec spec ->
            spec.args('--input', input.get().asFile, '--output', output.get().asFile, '--disable-abstract-param')
            mappingsIn.each {
                spec.args('--map', it)
            }
            spec.jvmArgs('-Xmx256M')
            spec.classpath(project.configurations.fart)
            spec.mainClass.set('net.minecraftforge.fart.Main')
        }
    }
}

abstract class InjectDocsTask extends DefaultTask {
    @InputFile
    abstract RegularFileProperty getInput()

    @OutputFile
    abstract RegularFileProperty getOutput()

    @InputFiles
    abstract ConfigurableFileCollection getClasspath()

    @Input
    abstract Property<Integer> getJavaVersion()

    InjectDocsTask() {
        output.convention(project.layout.file(project.provider { project.file("${project.buildDir}/${name}/output.jar") }))
    }

    @TaskAction
    void run() {
        final cp = getClasspath()
        output.get().asFile.delete()
        project.javaexec { JavaExecSpec spec ->
            spec.args('--input', input.get().asFile, '--output', output.get().asFile, '--java-version', 17)
            spec.jvmArgs('-Xmx256M')
            spec.classpath(cp)
            spec.mainClass.set('net.neoforged.javadoctor.injector.Main')
            spec.executable = project.extensions.getByType(JavaToolchainService).launcherFor {
                languageVersion = JavaLanguageVersion.of(javaVersion.get())
            }.get().executablePath
        }
    }
}